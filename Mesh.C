// Local header files
#include <vector>
#include "libmesh/elem.h"
#include "libmesh/face_tri3.h"
#include "libmesh/mesh.h"
#include "libmesh/mesh_generation.h"
#include "libmesh/mesh_tetgen_interface.h"
#include "libmesh/mesh_triangle_interface.h"
#include "libmesh/node.h"
#include "libmesh/serial_mesh.h"

// Bring in everything from the libMesh namespace
using namespace libMesh;

//This in the tetrahedralisation of a sphere
void tetrahedralise_sphere(const Parallel::Communicator& comm);

// makes the 'molecular mesh'

unsigned int closest(std::vector<Point> geom, Point pt);
std::vector<Point> get_water();

// Helper routine for tetrahedralize_domain().  Adds the points and elements
// of a convex hull generated by TetGen to the input mesh
void add_sphere_convex_hull_to_mesh(MeshBase& mesh, libMesh::Real radius, unsigned int points_on_sphere);
//void add_sphere_convex_hull_to_mesh(MeshBase& mesh, Point lower_limit, Point upper_limit);

// Begin the main program.
int main (int argc, char** argv){
   // Initialize libMesh and any dependent libaries, like in example 2.
   LibMeshInit init (argc, argv);
   
   libmesh_example_requires(3 <= LIBMESH_DIM, "3D support");
   out << "Tetrahedralizing a domain" << std::endl;
   
   // 2.) 3D tetrahedralization of rectangular domain with hole.
   //tetrahedralize_domain(init.comm());
   tetrahedralise_sphere(init.comm());
   
   return 0;
}

void tetrahedralise_sphere(const Parallel::Communicator& comm){
   #ifdef LIBMESH_HAVE_TETGEN
   // The algorithm is broken up into several steps:
   // 1.) A convex hull is constructed for a rectangular hole.
   // 2.) A convex hull is constructed for the domain exterior.
   // 3.) Neighbor information is updated so TetGen knows there is a convex hull
   // 4.) A vector of hole points is created.
   // 5.) The domain is tetrahedralized, the mesh is written out, etc.
   
   // The mesh we will eventually generate
   SerialMesh mesh(comm,3);
   libMesh::Real r=2.;
   
   // Lower and Upper bounding box limits for a rectangular hole within the unit cube.
   
   // 2.) Generate elements comprising the outer boundary of the domain.
   add_sphere_convex_hull_to_mesh(mesh, r, 37);
   
   // 3.) Update neighbor information so that TetGen can verify there is a convex hull.
   //mesh.find_neighbors();
   
   // 5.) Set parameters and tetrahedralize the domain
   
   // 0 means "use TetGen default value"
   Real quality_constraint = 2.0;
   
   // The volume constraint determines the max-allowed tetrahedral
   // volume in the Mesh.  TetGen will split cells which are larger than
   // this size
   Real volume_constraint = 1;  // no splitting at all. I want to see the input-parameters.
   
   // Construct the Delaunay tetrahedralization
   TetGenMeshInterface t(mesh);
   //t.triangulate_conformingDelaunayMesh(quality_constraint, volume_constraint);
   
   t.pointset_convexhull();
   mesh.find_neighbors();
   t.triangulate_conformingDelaunayMesh();
   
   // Find neighbors, etc in preparation for writing out the Mesh
   mesh.prepare_for_use();
   // Finally, write out the result
   mesh.write("sphere_3D.e");
   #else
   // Avoid compiler warnings
   libmesh_ignore(comm);
   #endif // LIBMESH_HAVE_TETGEN
}

void add_sphere_convex_hull_to_mesh(MeshBase& mesh, libMesh::Real radius, unsigned int points_on_sphere){
   #ifdef LIBMESH_HAVE_TETGEN
   SerialMesh sphere_mesh(mesh.comm(), 3);
   
   #ifndef LIBMESH_ENABLE_AMR
      out<<"You must enable adaptive mesh refinement for this to be working."<<std::endl;
   #endif
   // I don't know, what the last two arguments stand for.
   MeshTools::Generation::build_sphere(sphere_mesh, radius, 2, HEX8, 2, true);
   
   //sphere2MolecularGeom(sphere_mesh, geometry);
   
   // The pointset_convexhull() algorithm will ignore the Hex8s
   // in the Mesh, and just construct the triangulation
   // of the convex hull.
   TetGenMeshInterface t(sphere_mesh);
   t.pointset_convexhull();
   // Now add all nodes from the boundary of the sphere_mesh to the input mesh.
   // Map from "node id in sphere_mesh" -> "node id in mesh".  Initially inserted
   // with a dummy value, later to be assigned a value by the input mesh.
   std::map<unsigned,unsigned> node_id_map;
   typedef std::map<unsigned,unsigned>::iterator iterator;{
   MeshBase::element_iterator it = sphere_mesh.elements_begin();
   const MeshBase::element_iterator end = sphere_mesh.elements_end();
   for ( ; it != end; ++it){
       Elem* elem = *it;
       for (unsigned s=0; s<elem->n_sides(); ++s)
         if (elem->neighbor(s) == NULL){
             // Add the node IDs of this side to the set
             UniquePtr<Elem> side = elem->side(s);
             for (unsigned n=0; n<side->n_nodes(); ++n){
                node_id_map.insert( std::make_pair(side->node(n), /*dummy_value=*/0) );
             }
          }
       }
   }
   // set up the molecule: water
   std::vector<libMesh::Point> geometry ;
   geometry.resize(3);
   //geometry[0] = Point(1., 0.2, 7.0);
   geometry = get_water();
   Point xxx;
   // play with the following parameters:
   const double L=5.; // gives curvature: the larger L, the more straight line is obtained.
   const double r_max = 1.; // map to interval [0:r_max]
   const int N= 5;
   double x, scale;
   // For each node in the map, insert it into the input mesh and copy it to all nuclear sites.
   // keep track of the ID assigned.
   unsigned int molsize=geometry.size();
   //most outer loop: nuclear sites
   for(unsigned int i=0; i<molsize; i++){
      for (iterator it=node_id_map.begin(); it != node_id_map.end(); ++it){
         //scale the radius differently
         for( unsigned int circle=0; circle<N; circle++){
            // Id of the node in the cube mesh
            unsigned id = (*it).first;
            // Pointer to node in the spherical mesh
            Node* old_node = sphere_mesh.node_ptr(id);
            x = (double)(2.*circle)/N - 1.;
            scale = L*(1-x)/(1+x+2*L/r_max);
            if (scale == 0.)
               continue;
            old_node->operator*=(scale);
            old_node->add(geometry[i]);
            if (i==closest(geometry,sphere_mesh.point(id))){
             //  if (scale > 0.5){
             //     out<<"add"<<std::endl;
             //     out<<"coords: ";
             //     out<<old_node->operator()(0)<<" ";
             //     out<<old_node->operator()(1)<<" ";
             //     out<<old_node->operator()(2)<<"   "<<i<<std::endl;
             //  }
                  // Add geometric point to input mesh --> is this a hard copy??
               //Node* new_node = mesh.add_point( *old_node );
               Node* new_node = mesh.add_point( *old_node );
               
               // Track ID value of new_node in map
               (*it).second = new_node->id();
            }
            old_node->operator-= (geometry[i]);
            old_node->operator/= (scale);
         }
         // else: ignore it and go on with next value.
      }
   }
   // now, the point set is in mesh and we can call triangulate_pointset().
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh);
   libmesh_ignore(lower_limit);
   libmesh_ignore(upper_limit);
   #endif // LIBMESH_HAVE_TETGEN
}

unsigned int closest(std::vector<Point> geom, Point pt){
   unsigned int molsize=geom.size();
   //most outer loop: nuclear sites
   unsigned int closest=0;
   Point cl= geom[0]-pt;
   Point ac;
   for ( unsigned int i=1; i<molsize; i++ ){
      ac= geom[i]-pt;
      if ( ac.size()<cl.size() ){
         closest = i;
         cl = ac;
      }
   }
   return closest;
}

std::vector<Point> get_water(){
   std::vector<Point> geom;
   geom.resize(3);
   geom[0]= Point(0.,0.,0.12);
   geom[1]= Point(0.76263,0.,-0.4772);
   geom[2]= Point(-0.76263,0.,-0.4772);
   return geom;
}
