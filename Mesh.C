// Local header files
//#include "Mesh.h"
#include <vector>
#include "libmesh/elem.h"
#include "libmesh/face_tri3.h"
#include "libmesh/mesh.h"
#include "libmesh/mesh_generation.h"
#include "libmesh/mesh_tetgen_interface.h"
#include "libmesh/mesh_triangle_interface.h"
#include "libmesh/node.h"
#include "libmesh/serial_mesh.h"

// Bring in everything from the libMesh namespace
using namespace libMesh;

//This in the tetrahedralisation of a sphere
//void tetrahedralise_sphere(libMesh::MeshBase& mesh, const libMesh::Parallel::Communicator& comm);
//void tetrahedralise_sphere(libMesh::UnstructuredMesh& mesh, const libMesh::Parallel::Communicator& comm);
void tetrahedralise_sphere(libMesh::UnstructuredMesh& mesh, std::vector<Point> geometry);

// Helper routine for tetrahedralize_domain().  Adds the points and elements
// of a convex hull generated by TetGen to the input mesh
void add_sphere_convex_hull_to_mesh(libMesh::MeshBase& mesh, libMesh::Real radius, unsigned int points_on_sphere, std::vector<Point>);
void add_sphere_convex_hull_to_mesh2(libMesh::MeshBase& , libMesh::Real radius, unsigned int , std::vector<Point>, std::string creator);

unsigned int closest(std::vector<libMesh::Point> geom, libMesh::Point pt);

void tetrahedralise_sphere(UnstructuredMesh& mesh, std::vector<Point> geometry, std::string creator){
   #ifdef LIBMESH_HAVE_TETGEN
   libMesh::Real r=10.;
   
   if (creator=="own")
      add_sphere_convex_hull_to_mesh(mesh, r, 4, geometry);
   else
      add_sphere_convex_hull_to_mesh2(mesh, r, 70, geometry, creator);
   
   // 3.) Update neighbor information so that TetGen can verify there is a convex hull.
   mesh.find_neighbors();
   
   // 5.) Set parameters and tetrahedralize the domain
   
   // 0 means "use TetGen default value"
   Real quality_constraint = 0.0;
   
   // The volume constraint determines the max-allowed tetrahedral
   // volume in the Mesh.  TetGen will split cells which are larger than
   // this size
   Real volume_constraint = 5.; 
   
   // Construct the Delaunay tetrahedralization
   TetGenMeshInterface t(mesh);
   
   t.pointset_convexhull();
   mesh.find_neighbors();
   t.triangulate_conformingDelaunayMesh(quality_constraint, volume_constraint);
   
   
   // Find neighbors, etc in preparation for writing out the Mesh
   mesh.prepare_for_use();
   
   // Finally, write out the result --> is done in main already.
   //mesh.write("sphere_3D.e");
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh.comm);
   #endif // LIBMESH_HAVE_TETGEN
}

void add_sphere_convex_hull_to_mesh(MeshBase& mesh, libMesh::Real radius, unsigned int points_on_sphere, std::vector<Point> geometry){
   #ifdef LIBMESH_HAVE_TETGEN
   SerialMesh sphere_mesh(mesh.comm(), 3);
   
   #ifndef LIBMESH_ENABLE_AMR
      out<<"You must enable adaptive mesh refinement for this to be working."<<std::endl;
   #endif
   // I don't know, what the last two arguments stand for.
   MeshTools::Generation::build_sphere(sphere_mesh, radius, points_on_sphere, HEX8, 4, true);
   
   // The pointset_convexhull() algorithm will ignore the Hex8s
   // in the Mesh, and just construct the triangulation
   // of the convex hull.
   TetGenMeshInterface t(sphere_mesh);
   t.pointset_convexhull();
   // Now add all nodes from the boundary of the sphere_mesh to the input mesh.
   // Map from "node id in sphere_mesh" -> "node id in mesh".  Initially inserted
   // with a dummy value, later to be assigned a value by the input mesh.
   std::map<unsigned,unsigned> node_id_map;
   typedef std::map<unsigned,unsigned>::iterator iterator;{
   MeshBase::element_iterator it = sphere_mesh.elements_begin();
   const MeshBase::element_iterator end = sphere_mesh.elements_end();
   for ( ; it != end; ++it){
       Elem* elem = *it;
       for (unsigned s=0; s<elem->n_sides(); ++s)
         if (elem->neighbor(s) == NULL){
             // Add the node IDs of this side to the set
             UniquePtr<Elem> side = elem->side(s);
             for (unsigned n=0; n<side->n_nodes(); ++n){
                node_id_map.insert( std::make_pair(side->node(n), /*dummy_value=*/0) );
             }
          }
       }
   }
   Point xxx;
   // play with the following parameters:
   const double L=1.; // gives curvature: the larger L, the more straight line is obtained.
   const double r_max = 1.; // map to interval [0:r_max]
   const int N= 3;
   double x, scale;
   // For each node in the map, insert it into the input mesh and copy it to all nuclear sites.
   // keep track of the ID assigned.
   unsigned int molsize=geometry.size();
   //most outer loop: nuclear sites
   for(unsigned int i=0; i<molsize; i++){
      for (iterator it=node_id_map.begin(); it != node_id_map.end(); ++it){
         //scale the radius differently
         for( unsigned int circle=0; circle<N; circle++){
            // Id of the node in the cube mesh
            unsigned id = (*it).first;
            // Pointer to node in the spherical mesh
            Node* old_node = sphere_mesh.node_ptr(id);
            x = (double)(2.*circle)/N - 1.;
            scale = L*(1-x)/(1+x+2*L/r_max);
            if (scale == 0.)
               continue;
            old_node->operator*=(scale);
            old_node->add(geometry[i]);
            if (i==closest(geometry,sphere_mesh.point(id))){
               // Add geometric point to input mesh --> is this a hard copy??
               Node* new_node = mesh.add_point( *old_node );
               // Track ID value of new_node in map
               (*it).second = new_node->id();
            }
            // else: ignore it and go on with next value.

            old_node->operator-= (geometry[i]);
            old_node->operator/= (scale);
         }
      }
   }
   // now, the point set is in mesh and we can call triangulate_pointset().
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh);
   libmesh_ignore(lower_limit);
   libmesh_ignore(upper_limit);
   #endif // LIBMESH_HAVE_TETGEN
}

std::vector<Point> fibonacci(unsigned int points_on_sphere){
   std::vector<Point> points(points_on_sphere);
   double x,y,z,r,phi;
   double pi=3.1415926;
   for (unsigned int i=0; i<points_on_sphere; i++){
      y=2.*i/points_on_sphere-1.;
      r=sqrt(1.-y*y);
      phi=i*pi*(3.-sqrt(5.));
      z=r*sin(phi);
      x=r*cos(phi);
      points[i]=Node(x,y,z);
      //out<<points[i]<<std::endl;
   }
   //out<<std::endl<<std::endl;
   return points;
}

std::vector<Point> archimedes(unsigned int points_on_sphere){
   int n=floor(sqrt(points_on_sphere));
   std::vector<Point> points(n*n);
   double theta, phi;
   for(int i=0; i<n; i++){
      theta=i*6.2831852/n;
      for(int j=1; j<=n; j++){
         phi=acos(2.*j/(n+1)-1.);
         points[i*n+j-1]=Node(cos(theta)*sin(phi),
                   sin(theta)*sin(phi), 
                   2.*j/(n+1)-1.);
      //out<<points[i*n+j-1]<<std::endl;
      }
   }
   return points;
}

std::vector<Point> spiral(unsigned int points_on_sphere){
   std::vector<Point> points(points_on_sphere);
   double pi=3.1415926;
   double dl=pi*(3.-sqrt(5.));
   double dz=2./points_on_sphere;
   double z, l, r;
   for(unsigned int i=0; i<points_on_sphere; i++){
      z=1.-dz/2.*i;
      l=i*dl;
      r=sqrt(1.-z*z);
      points[i]=Node(r*cos(l),r*sin(l),z);
   }
   return points;
}

void add_sphere_convex_hull_to_mesh2(MeshBase& mesh, libMesh::Real r_max, unsigned int points_on_sphere, std::vector<Point> geometry, std::string creator){
   #ifdef LIBMESH_HAVE_TETGEN
   std::vector<Point> point;
   if (creator=="fibonacci")
      point=fibonacci(points_on_sphere);
   else if (creator=="archimedes")
      point=archimedes(points_on_sphere);
   else if (creator=="spiral")
      point=spiral(points_on_sphere);

   // play with the following parameters:
   const double L=2.1; // gives curvature: the larger L, the more straight line is obtained.
   const int N= 12;
   double x, scale;
   // For each point in the map, insert it into the input mesh and copy it to all nuclear sites.
   // keep track of the ID assigned.
   unsigned int molsize=geometry.size();
   //most outer loop: nuclear sites
   for(unsigned int i=0; i<molsize; i++){
      // add one point each at the nuclear position:
      mesh.add_point( geometry[i] );
      for (unsigned int it=0; it<point.size(); it++){
         //scale the radius differently
         for( unsigned int circle=0; circle<N; circle++){
            // Pointer to node in the spherical mesh
            //out<<"   "<<point[it]<<std::endl;
            x = (double)(2.*circle)/N - 1.;
            scale = L*(1.-x)/(1.+x+2.*L/r_max);
            if (scale == 0.)
               continue;
            //out<<"    "<<scale<<std::endl;
            //out<<"    "<<geometry[i]<<std::endl;
            point[it]*=scale;
            point[it]+=geometry[i];
            if (i==closest(geometry, point[it])){
               mesh.add_point( point[it] );
               //out<<point[it]<<std::endl;
            }
            point[it]-= geometry[i];
            point[it]/= scale;
         }
         // else: ignore it and go on with next value.
      }
   }
   // now, the point set is in mesh and we can call triangulate_pointset().
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh);
   libmesh_ignore(lower_limit);
   libmesh_ignore(upper_limit);
   #endif // LIBMESH_HAVE_TETGEN
}

unsigned int closest(std::vector<Point> geom, Point pt){
   unsigned int molsize=geom.size();
   //most outer loop: nuclear sites
   unsigned int closest=0;
   Point cl= geom[0]-pt;
   Point ac;
   for (unsigned int i=1; i<molsize; i++ ){
      ac= geom[i]-pt;
      if ( ac.size()<cl.size() ){
         closest = i;
         cl = ac;
      }
   }
   return closest;
}
