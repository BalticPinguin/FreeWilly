// Local header files
//#include "Mesh.h"
#include <vector>
#include "libmesh/elem.h"
#include "libmesh/face_tri3.h"
#include "libmesh/mesh.h"
#include "libmesh/mesh_generation.h"
#include "libmesh/mesh_tetgen_interface.h"
#include "libmesh/mesh_triangle_interface.h"
#include "libmesh/node.h"
#include "libmesh/serial_mesh.h"

// for the lebedev-grids
# include "fsu_soft/sphere_lebedev_rule.hpp"
# include "fsu_soft/sphere_design_rule.hpp"
# include "grids/Wom.h"

// Bring in everything from the libMesh namespace using namespace libMesh;
using namespace libMesh;

// Helper routine for tetrahedralize_domain().  Adds the points and elements
// of a convex hull generated by TetGen to the input mesh
void add_sphere_convex_hull_to_mesh(MeshBase& mesh, libMesh::Real r_max, unsigned int points_on_sphere, std::vector<Node> geometry, std::string creator, const Real L, const unsigned int N);

unsigned int closest(std::vector<libMesh::Node> geom, libMesh::Point pt);

unsigned int point_size(unsigned int iterations, int n);

void tetrahedralise_sphere(UnstructuredMesh& mesh, std::vector<Node> geometry, std::string creator, Real r, int NrBall, Real VolConst, Real L, unsigned int N){
   #ifdef LIBMESH_HAVE_TETGEN
   //libMesh::Real r=10.;
   
   add_sphere_convex_hull_to_mesh(mesh, r, NrBall, geometry, creator, L, N);
   
   //mesh.write("sphere_3D.e");
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh.comm);
   #endif // LIBMESH_HAVE_TETGEN
}

std::vector<Point> fibonacci(unsigned int points_on_sphere){
   std::vector<Point> points(points_on_sphere);
   double x,y,z,r,phi;
   double pi=3.1415926;
   for (unsigned int i=0; i<points_on_sphere; i++){
      y=2.*i/points_on_sphere-1.;
      r=sqrt(1.-y*y);
      phi=i*pi*(3.-sqrt(5.));
      z=r*sin(phi);
      x=r*cos(phi);
      points[i]=Node(x,y,z);
      //out<<points[i]<<std::endl;
   }
   //out<<std::endl<<std::endl;
   return points;
}

std::vector<Point> archimedes(unsigned int points_on_sphere){
   int n=floor(sqrt(points_on_sphere));
   std::vector<Point> points(n*n);
   double theta, phi;
   for(int i=0; i<n; i++){
      theta=i*6.2831852/n;
      for(int j=1; j<=n; j++){
         phi=acos(2.*j/n -1.);
         points[i*n+j-1]=Node(cos(theta)*sin(phi),
                   sin(theta)*sin(phi), 
                   2.*j/(n+1.)-1.);
      //out<<points[i*n+j-1]<<std::endl;
      }
   }
   return points;
}

std::vector<Point> spiral(unsigned int points_on_sphere){
   std::vector<Point> points(points_on_sphere);
   double pi=3.1415926;
   double dl=pi*(3.-sqrt(5.));
   double dz=2./(points_on_sphere +1.);
   double z, l, r;
   for(unsigned int i=1; i<=points_on_sphere; i++){
      z=i*dz-1.;
      l=i*dl;
      r=sqrt(1.-z*z);
      points[i-1]=Node(r*cos(l),r*sin(l),z);
   }
   return points;
}

void add_sphere_convex_hull_to_mesh(MeshBase& mesh, libMesh::Real r_max, unsigned int points_on_sphere, std::vector<Node> geometry, std::string creator, const Real L, const unsigned int N){
   #ifdef LIBMESH_HAVE_TETGEN
   std::vector<Point> point;
   // For each point in the map, insert it into the input mesh and copy it to all nuclear sites.
   // keep track of the ID assigned.
   unsigned int molsize=geometry.size();
   unsigned int pts_circle;

   // add one node each at the nuclear position.
   for(unsigned int i=0; i<molsize; i++){
      // add one point each at the nuclear position:
      mesh.add_point( geometry[i]);
   }

   //now, add further points to the mesh: The nodes are located on spheres (circle)
   out<<std::endl<<"BEGIN POINT SET"<<std::endl<<std::endl;

   //outermost loop: over different spheres
   for(unsigned int circle=0; circle<1; circle++){
      // create a unit sphere of respective type with slowly incr. number of points
      pts_circle=(int)(r_max*0.3+1)*points_on_sphere;
      //pts_circle=points_on_sphere;
      if (creator=="fibonacci")
         point=fibonacci(pts_circle);
      else if (creator=="archimedes")
         point=archimedes(pts_circle);
      else if (creator=="spiral")
         point=spiral(pts_circle);
      else if (creator=="Sdesign"){
         int rule, num_pts;
         rule = (int)sqrt(pts_circle/2)/3;
         design_size(rule, &num_pts);
         double** x;
         x= new double*[3];
         x[0]=new double[num_pts];
         x[1]=new double[num_pts];
         x[2]=new double[num_pts];
         design_points(rule, num_pts, x);
         point.resize(num_pts);
         for(int i=0; i<num_pts; i++){
            point[i]=Point(x[0][i],x[1][i],x[2][i]);
         }
         delete[] x;
      }
      else{
         //set the order:
         int rule, num_pts;
         if (creator=="lebedev"){
            rule = (unsigned int)sqrt(pts_circle/2);
            while (available_table(rule)==0)
               // if it is 1, I can work with it
               // if -1, it has become too large.
               rule++;
            num_pts=order_table (rule);
         }
         else if (creator=="geodesic4"){
            rule=(int)log(pts_circle);
            num_pts=point_size(4, rule);
         }
         else if (creator=="geodesic6"){
            rule=(int)log(pts_circle);
            num_pts=point_size(6, rule);
         }
         else{ // some Womersley
            rule = (int)sqrt(pts_circle/2)/6;
            if(unavailable(rule))
               rule=max_avail();
            num_pts=Wom_precision_table(rule);
         }
         // not all orders are implemented.
         out<<"order? "<<num_pts<<"  ";
         out<<pts_circle<<std::endl;
         double *x, *y, *z, *w;
         x= new double[num_pts];
         y= new double[num_pts];
         z= new double[num_pts];
         w= new double[num_pts];
         if (creator=="lebedev")
            ld_by_order (num_pts, x, y, z, w);
         else if (creator=="womEV")
            Wom_points (1, num_pts, x, y, z, w);
         else if (creator=="womMD")
            Wom_points (2, num_pts, x, y, z, w);
         else if (creator=="womMN")
            Wom_points (3, num_pts, x, y, z, w);
         else if (creator=="fliME") 
            Wom_points (4, num_pts, x, y, z, w);
         else
            libmesh_error_msg("no valid creator specified.\n");
         // this is not needed at all.
         delete [] w; 

         // now, convert the arrays to a Point-vector.
         point.resize(num_pts);
         for(int i=0; i<num_pts; i++){
            point[i]=Point(x[i],y[i],z[i]);
         }
         delete [] x;
         delete [] y;
         delete [] z;
      }
      // loop over atoms: each of them has a shpere around it
      for(unsigned int i=0; i<molsize; i++){
         // loop over the points on the sphere and add it respectively.
         for (unsigned int it=0; it<point.size(); it++){
            point[it]+=geometry[i];
            if (i==closest(geometry, point[it])){
               mesh.add_point( point[it] );
               out<<point[it](0)<<"  ";
               out<<point[it](1)<<"  ";
               out<<point[it](2)<<std::endl;
            }
            point[it]-= geometry[i];
         }
      }
   }
   out<<std::endl<<"END POINT SET"<<std::endl;
   // now, the point set is in mesh and we can call triangulate_pointset().
   #else
   // Avoid compiler warnings
   libmesh_ignore(mesh);
   libmesh_ignore(lower_limit);
   libmesh_ignore(upper_limit);
   #endif // LIBMESH_HAVE_TETGEN
}

unsigned int closest(std::vector<Node> geom, Point pt){
   unsigned int molsize=geom.size();
   //most outer loop: nuclear sites
   unsigned int closest=0;
   Point cl= geom[0]-pt;
   Point ac;
   for (unsigned int i=1; i<molsize; i++ ){
      ac= geom[i]-pt;
      if ( ac.size()<cl.size() ){
         closest = i;
         cl = ac;
      }
   }
   return closest;
}
